---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by LoanSens.
--- DateTime: 20/06/2018 21:05
---

local MameCmd = require("mameCmd")
require("class")

Creature = class(function(this, mapFocus, inputsManager, neurons, screen, p1, textX, textY)
    this.map = mapFocus
    this.inputsManager = inputsManager
    this.p1 = p1

    this.drawScreen = screen
    this.neurons = neurons -- Make a copy ?

    this.fitness = 0
    this.previousMarioX = nil

    this.textX = textX
    this.textY = textY

    -- Random seed is always the same on start, use this counter to have distinct random number
    this.randomCounter = 0
    this.alreadyTested = false
end)

function Creature:copy()
    local copyNeurons = {}
    for i, v in ipairs(self.neurons) do
        copyNeurons[i] = v:copy()
    end
    local copyCreature = Creature(self.map, self.inputsManager, copyNeurons, self.drawScreen, self.p1, self.textX, self.textY)
    return copyCreature
end

function Creature:setTested()
    self.alreadyTested = true
end

function Creature:isTested()
    return self.alreadyTested
end

function Creature:isDead()
    -- If mario is dead
    return MameCmd.readMemory(0xE) == 0x0B
end


function Creature:mutate()
    -- TODO : mutate
    self:randomize(os.time()+12)
    print("Mutation !!")
end




function Creature:randomize(r)
    self.randomCounter = self.randomCounter + (r+1)*121
    math.randomseed(os.time() + self.randomCounter)
    for i = 1, math.random(20) do
        self:addRandomNeuron()
    end
end

function Creature:getRandomElementOfTable(myTable)
    -- iterate over whole table to get all keys
    local keyset = {}
    for k in pairs(myTable) do
        table.insert(keyset, k)
    end
    -- now you can reliably return a random key
    return myTable[keyset[math.random(#keyset)]]
end

function Creature:addRandomNeuron()
    math.randomseed(os.time() + self.randomCounter)

    local randomX = math.random(self.map:getW())
    local randomY = math.random(self.map.height)
    local randomTile = self:getRandomElementOfTable(tileEnum)
    local randomInput = math.random(#inputsNes)

    local newNeuron = Neuron(self.map, randomX, randomY, randomTile, self.inputsManager, randomInput, self.p1)
    self:addNeuron(newNeuron)
    self.randomCounter = self.randomCounter + 1
end

function Creature:addNeuron(neuron)
    table.insert(self.neurons, neuron)
end

function Creature:updateFitness()
    -- Increase as mario go right
    local marioX = self.map:getMarioX()
    if (self.previousMarioX ~= nil) then
        local difference = marioX-self.previousMarioX
        if difference > -8 then -- Avoid huge drops on screen changes (warp, level end)
            self.fitness = self.fitness + difference
        end
    end
    self.previousMarioX = marioX
end

function Creature:getFitness()
    return self.fitness
end

function Creature:updateNeurons()
    -- Update all input to unpressed
    for _, v in pairs(inputsNes) do
        self.p1.fields[v]:set_value(0)
    end
    -- Neuron them self press any button they are map to if needed
    for _, v in pairs(self.neurons) do
        v:check()
    end
end

function Creature:draw()
    -- Draw neural network
    for _, v in pairs(self.neurons) do
        v:draw(self.drawScreen)
    end

    -- Other text informations
    local text = "Fitness : " .. self.fitness .. " " .. tostring(self.alreadyTested)
    self.drawScreen:draw_text(self.textX+0.5, self.textY, text, 0xff000000)
    self.drawScreen:draw_text(self.textX, self.textY, text, 0xffffffff)
end

function Creature:__tostring()
    local ret = ""
    ret = ret .. "Neurons : "
    for _, v in pairs(self.neurons) do
        ret = ret .. "\t" .. tostring(v) .. "\n"
    end
    return ret
end